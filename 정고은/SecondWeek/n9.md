# 9장 HTTP

Http - 인터넷에서 데이터를 주고받는 통신 규약

TCP - 직접 연결하며 1:1 연결이다. 통신이 안정적이고 흐름제어 및 혼잡제어를 할 수 있다.

UDP - 비연결 통신을 한다. 보내는 쪽에서 받는 쪽이 데이터를 받았는지의 여부를 확인할 수 없고, 확인할 필요도 없도록 만들어진 프로토콜. 신뢰도가 떨어지고 흐름제어 및 혼잡 제어가 힘들어진다.

TCP vs UDP

공통점 - 포트 번호를 이용하여 주소를 지정한다. 두 어플리케이션이 통신하기 위해서는 반드시 포트 번호를 결정해야 한다., 데이터 오류를 체크한다. 헤더와 데이터에 대한 오류를 체크한다.

차이점

- 연결형 vs 비연결형 : TCP는 연결이 성공해야 통신이 가능하지만, UDP는 연결없이 통신이 가능하다.
- 데이터의 신뢰성 : TCP는 데이터를 재전송, UDP는 데이터를 재전송 하지 않는다.

###### Connectless & Stateless

HTTP는 Connectless 방식으로 작동한다. 서버에 연결하고 요청을 받고 응답을 하면 연결을 끊어버린다. 기본적으로는 자원 하나에 대해 하나의 연결을 만든다.

장점 : 불특정 다수를 하는 서비스에 적합한 방식이다, 수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.

단점 : 연결을 끊어버리기 때문에 클라이언트의 이전 상태를 알 수 없다. 이러한 HTTP의 특징을 Connectless로부터 파생되는 stateless라고 한다, 따라서 HTTP는 cookies를 이용해서 이 문제를 해결하고 있다.

##### 쿠키

클라이언트와 서버 상태를 담고 있는 조각 정보.

예를들어 클라이언트가 로그인에 성공하면 서버는 로그인 정보를 자신의 데이터베이스에 저장하고 동일한 값을 cookies 형태로 클라이언트에 보낸다.

1. 첫 요청시

   클라이언트 로그인 성공 -> 서버 로그인 정보를 자신의 DB에 저장.

   그리고 쿠키를 클라이언트에 반환한다.

   DB에서 SELECT해와서 로그인 여부를 확인할 수 있다.

2. 두번째 요청 시

   클라이언트가 서버에서 request시, 쿠키를 같이 전달해 준다.

   그리고 서버에서 DB를 조회하여 로그인 여부를 확인한다.

HTTP 응답 코드 : 2XX - 성공, 4XX - 클라이언트 오류, 5XX - 서버 오류

HTTP 메소드 : GET, POST, HEAD-GET과 비슷하지만 HEAD부분만 존재-, OPTIONS-서버에서 지원하는 HTTP 메소드를 알아내기 위해-, PUT, DELETE, TRACE-클라이언트의 요청을 그대로 반환-

HTTP 요청

요청 라인 - HTTP 메소드, 타겟, HTTP 버전.

헤더 - Host-타켓의 호스트의 URL주소-, User-agent-클라이언트의 관한 정보-, Accpet-해당 요청이 받을 수 있는 응답 body 데이터 타입을 알려줌. ex. application/json-, Connection-요청이 끝난 후 연결 유지 여부-, Content-Type-HTTP 요청을 보내는 메세지 body의 타입, 만약 HTTP 요청이 JSON데이터를 전송하면 Content-Type: application/json이다,-, Content-Lengh

바디 - 요청에 필요한 데이터가 담겨져 있음. 전송하는 데이터가 없다면 비어 있다.

응답

요청 라인 - HTTP 버전, 상태 코드, 상태 텍스트

헤더 - 요청의 헤더 부분과 동일. User-Agent -> Server처럼 응답헤더에서만 사용되는 헤더 값이 있긴 하다.

바디 - 요청과 동일.

https 암호화 방식 - 공개키 암호화 과정

# 궁금증

HTTP 위키 요약표에 있는 요청, 응답의 Body, 캐시 가능이 궁금하다.



# 자습

공개키 암호화 과정에 대한 설명을 이해 못하겠어서 자습하였다.

#### 대칭키 방식

동일한 키로 암호화, 복호화를 동시에 할 수 있다. 예를 들어 'abcd'라는 키로 암호화를 하면, 복호화 시에 'abcd'를 입력해야 한다. 따라서 누군가가 대칭키를 획득한다면 쉽게 암호화된 데이터를 알아낼 수 있다.

#### 공개키 방식

대칭키 방식의 단점을 보완하기 위함.

두 개의 키를 갖는다. 누구에게나 공개가 가능한 공개키, 자신만이 갖고 있는 개인키(비밀키)

공개키로 암호화를 하냐, 개인키로 암호화를 하냐에 따라 사용분야가 달라진다. 공개키로 암호화를 하면 데이터 보안에 중점을 두고, 개인키로 암호화를 하면 인증 과정에 중점을 두는 것이다.

1. 공개키로 암호화를 하는 경우

   상대방의 공개키로 데이터를 암호화하고 데이터를 전달하면, 데이터를 전달받은 사람은 자신의 개인키로 데이터를 복호화한다. 

   암호화, 복호화할 수 있는 서로 다른 키 2개가 존재하는데 이 두 개의 키는 서로 1번 키로 암호화하면 반드시 2번키로만 복호화할 수 있고 2번 키로 암호화하면 반드시 1번키로만 복호화할 수 있는 룰이 있다.

   그 중에 하나 키는 모두에게 공개하는 공개키(1번 키)로 만들어서 공개키 저장소에 등록해놓는다.

   서버는 서버만 알 수 있는 개인키(2번 키)를 소유하고 있으면 된다.

   그러면 1번키로 암호화된 http 요청, 즉 HTTPS 프로토콜을 사용한 요청이 온다면 서버는 개인키(2번 키)를 이용하여 암호화된 문장을 해독하게 된다.

   서버는 요청이 무엇인지 알게되고 요청에 맞는 응답을 다시 개인키(2번 키)로 암호화해서 요청한 클라이언트에게 보내주게 된다. 그리고 응답을 받은 클라이언트는 공개키(1번 키)를 이용해서 개인키(2번 키)로 암호화된 HTTPS 응답을 해독하고 사용하는 시나리오다.

   공개키는 누구나 얻을 수 있고 공개키를 알면 서버가 주는 데이터(response)는 알 수 있는데 보안상의 의미가 있을까? -> 없으나 이점은 해당 서버로부터 온 응답임을 확신할 수 있다. 공개키로 해독이 가능했으니 반드시 해당 서버의 개인키로 암호화했다는 것을 보장하기 때문이다.

   #### HTTPS 통신 흐름

   공개키 저장소의 원래 명칭은 CA이다. CA는 민간기업이지만 아무나 운영할 수 없고 신뢰성이 검증된 기업만 CA를 운영할 수 있다.

   1. 먼저 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.
   2. 그 다음 신뢰할 수 있는 CA 기업을 선택하고 그 기업에 내 공개키를 관리해달라고 계약하고 돈을 지불한다.
   3. 계약을 완료한 CA기업업은 또 CA 기업만의 공개키와 개인키가 있다. CA 기업은 CA 기업의 이름과 A서버의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다. 
   4. A서버는 암호화된 인증서를 갖게 되었다. A서버는 공개키로 암호화된 HTTPS 요청이 아닌 요청(Request)이 오면 이 암호화된 인증서를 클라이언트에게 준다.
   5. 클라이언트 입장에서는 예를들어 A서버로 index.html 파일을 달라고 요청했다. 그러면 HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.
   6. 하지만 세계적으로 신뢰할 수 있는 CA 기업의 공개키는 브라우저가 이미 알고 있다.
   7. 브라우저가 CA 기업 리스트를 쭉 탐색하면서 인증서에 적혀있는 CA기업 이름이 같으면 해당 CA기업의 공개키를 이미 알고 있는 브라우저는 해독할 수 있다. 그러면 해독해서 A서버의 공개키를 얻는다.
   8. 그러면 A서버와 통신할 때는 A서버의 공개키로 암호화해서 Request를 날리게 된다.

   https를 지원한다고 해서 무조건 안전한 것은 아니다. 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문이다.

2. 개인키로 암호화를 하는 경우

   개인키의 소유자가 개인키로 데이터를 암호화하고 공개키와 함께 전달한다. 이 과정에서 공개키와 데이터를 획득한 사람은 공개키를 이용하여 복호화가 가능하다. 이런 위험에도 불구하고 이 방법을 사용하는 이유는 데이터 보호의 목적보다는 공개키가 데이터 제공자의 신원을 보장해주기 때문이다. 암호화된 데이터가 공개키로 복호화된다는 것은 공개키와 쌍을 이루는 개인키에 의해 암호화되었다는 것을 의미한다. 즉 데이터의 제공자의 신원 확인이 보장된다는 것이다.

   전자서명의 과정이다.



공개키와 개인키는 거의 그림이 비슷한데 둘의 차이는 암호화를 공개키로 먼저 하느냐, 개인키로 먼저 하느냐의 차이로 이름이 갈린 거 같다.

공개키 암호화 방식을 읽으니까 적당히... 알게는 되는데 깊이는 이해 못할거같다 ㅎ.ㅎ



##### SSL 인증서

SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다. 즉 클라이언트와 서버가 주고받는 실제 정보는 대칭키 방식으로 암호화하고, 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고받는다.

1. 악수(handshaek)

   SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데 이때 SSL 인증서를 주고 받는다. 공개키는 이상적인 통신 방식이나 매우 많은 컴퓨터 자원을 사용하기 대문에 이 방식을 사용하지 않는다. 반면에 암호화와 복호화에 사용되는 키가 동일한 대칭키 방식은 적은 컴퓨터 자원으로 암호화를 수행할 수 있기 때문에 효율적이지만 보안의 문제가 발생한다. 그래서 SSL은 공개키와 대칭키의 장점을 혼합한 방법을 사용한다. 핸드쉐이크 단계에서 클라이언트와 서버가 통신하는 과정을 순서대로 살펴보자.

   1. 클라이언트가 서버에 접속한다. 이 단계에서 주고받는 정보는 아래와 같다.

      - 클라이언트 측에서 생성한 랜덤 데이터
      - 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
      - 세션 아이디: 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해 기존의 세션을 재활용하게 되는데 이때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

   2. 서버는 Client Hello에 대한 응답으로 Server Hello를 한다.

      - 서버 측에서 생성한 랜덤 데이터
      - 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
      - 인증서

   3. 클라이언트는 서버의 인증서가 CA에 의해 발급된 것인지를 확인하기 위해 클라이언트에 내장된 CA 리스트를 확인한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.

      클라이언트는 서버의 랜덤데이터와 클라이언트의 랜덤 데이터를 조합해서 pre master secret이라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고받을 때 암호화하기 위해 사용될 것이다. 이떄 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대 노출되면 안된다.

      pre master secret 값을 공개키 방식으로 전달한다. 서버의 공개키로 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화할 수 있다. 서버의 공개키는 서버로부터 받은 인증키 안에 들어있다. 서버와 클라이언트는 모두 일련의 과정을 거쳐 pre master secret 값을 master secret 값으로 만든다. master secret은 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화한 후에 주고받는다.

   4. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

2. 세션

   데이터를 상대방에게 전송하기 전에 session key 값을 이용해 대칭키 방식으로 암호화한다.

3. 세션 종료

   데이터의 전송이 끝났으면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 사용한 대칭키인 세션키를 폐기한다.



handshake와 session key를 만드는 과정이 짧은지, 세션 종료를 많이 하는지 궁금하다